-- =====================================================
-- REPORTING & INSIGHTS LAYER MIGRATION
-- Sprint 29: AI-driven reporting and strategic insights
-- =====================================================

-- =====================================================
-- ENUMS
-- =====================================================

-- Report types
CREATE TYPE report_type AS ENUM (
  'CAMPAIGN',      -- Campaign performance report
  'STRATEGY',      -- Strategy effectiveness report
  'PERFORMANCE',   -- Overall performance metrics
  'INSIGHTS',      -- Strategic insights and recommendations
  'CUSTOM'         -- Custom report from template
);

-- Report generation status
CREATE TYPE report_status AS ENUM (
  'PENDING',       -- Queued for generation
  'GENERATING',    -- Currently generating
  'COMPLETE',      -- Successfully generated
  'FAILED'         -- Generation failed
);

-- =====================================================
-- REPORT TEMPLATES TABLE
-- =====================================================

CREATE TABLE report_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,

  -- Template metadata
  name TEXT NOT NULL,
  description TEXT,
  report_type report_type NOT NULL,

  -- Template configuration
  sections JSONB NOT NULL DEFAULT '[]', -- Array of section configs
  metrics_config JSONB DEFAULT '{}',    -- Which metrics to include

  -- GPT configuration
  gpt_prompt_template TEXT,             -- Custom prompt for GPT
  include_recommendations BOOLEAN DEFAULT true,
  include_strategic_insights BOOLEAN DEFAULT true,

  -- Template options
  is_default BOOLEAN DEFAULT false,
  is_active BOOLEAN DEFAULT true,

  -- Ownership
  created_by UUID REFERENCES users(id),

  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Indexes
  CONSTRAINT report_templates_org_name_unique UNIQUE(organization_id, name)
);

CREATE INDEX idx_report_templates_org ON report_templates(organization_id);
CREATE INDEX idx_report_templates_type ON report_templates(report_type);
CREATE INDEX idx_report_templates_default ON report_templates(organization_id, is_default) WHERE is_default = true;

-- =====================================================
-- GENERATED REPORTS TABLE
-- =====================================================

CREATE TABLE generated_reports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,

  -- Report metadata
  report_type report_type NOT NULL,
  template_id UUID REFERENCES report_templates(id) ON DELETE SET NULL,

  -- References
  campaign_id UUID REFERENCES campaigns(id) ON DELETE CASCADE,
  strategy_id UUID REFERENCES strategy_plans(id) ON DELETE SET NULL,

  -- Report content
  title TEXT NOT NULL,
  status report_status NOT NULL DEFAULT 'PENDING',

  -- GPT-generated content
  executive_summary TEXT,               -- High-level GPT summary
  key_findings TEXT[],                  -- Array of key insights
  strategic_recommendations TEXT[],     -- Array of recommendations
  performance_analysis TEXT,            -- GPT analysis of metrics
  agent_effectiveness_summary TEXT,     -- GPT analysis of agent performance
  sentiment_analysis TEXT,              -- GPT sentiment insights

  -- Structured metrics snapshot
  metrics_snapshot JSONB DEFAULT '{}',  -- Raw metrics at generation time

  -- Report sections (structured)
  sections JSONB DEFAULT '[]',          -- Array of report sections with content

  -- Chart data (for frontend)
  charts JSONB DEFAULT '[]',            -- Array of chart configurations

  -- Metadata
  generation_started_at TIMESTAMPTZ,
  generation_completed_at TIMESTAMPTZ,
  generation_duration_ms INTEGER,

  -- Error tracking
  error_message TEXT,
  retry_count INTEGER DEFAULT 0,

  -- Timeframe
  period_start TIMESTAMPTZ,
  period_end TIMESTAMPTZ,

  -- Generated by
  requested_by UUID REFERENCES users(id),

  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_generated_reports_org ON generated_reports(organization_id);
CREATE INDEX idx_generated_reports_campaign ON generated_reports(campaign_id);
CREATE INDEX idx_generated_reports_status ON generated_reports(status);
CREATE INDEX idx_generated_reports_type ON generated_reports(report_type);
CREATE INDEX idx_generated_reports_created ON generated_reports(created_at DESC);

-- =====================================================
-- ADD COLUMNS TO CAMPAIGNS
-- =====================================================

ALTER TABLE campaigns
ADD COLUMN latest_report_id UUID REFERENCES generated_reports(id) ON DELETE SET NULL;

CREATE INDEX idx_campaigns_latest_report ON campaigns(latest_report_id);

-- =====================================================
-- ROW LEVEL SECURITY (RLS)
-- =====================================================

ALTER TABLE report_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE generated_reports ENABLE ROW LEVEL SECURITY;

-- Report Templates Policies
CREATE POLICY report_templates_org_isolation ON report_templates
  FOR ALL
  USING (organization_id IN (
    SELECT organization_id FROM users WHERE id = auth.uid()
  ));

-- Generated Reports Policies
CREATE POLICY generated_reports_org_isolation ON generated_reports
  FOR ALL
  USING (organization_id IN (
    SELECT organization_id FROM users WHERE id = auth.uid()
  ));

-- =====================================================
-- POSTGRESQL FUNCTIONS
-- =====================================================

/**
 * Generate campaign report (orchestration function)
 * Triggers the report generation pipeline
 */
CREATE OR REPLACE FUNCTION generate_campaign_report(
  p_campaign_id UUID,
  p_organization_id UUID,
  p_user_id UUID,
  p_template_id UUID DEFAULT NULL,
  p_period_start TIMESTAMPTZ DEFAULT NULL,
  p_period_end TIMESTAMPTZ DEFAULT NULL
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_report_id UUID;
  v_template report_templates%ROWTYPE;
  v_campaign campaigns%ROWTYPE;
BEGIN
  -- Get campaign
  SELECT * INTO v_campaign
  FROM campaigns
  WHERE id = p_campaign_id AND organization_id = p_organization_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Campaign not found';
  END IF;

  -- Get template (or default)
  IF p_template_id IS NOT NULL THEN
    SELECT * INTO v_template
    FROM report_templates
    WHERE id = p_template_id AND organization_id = p_organization_id;
  ELSE
    -- Get default CAMPAIGN template
    SELECT * INTO v_template
    FROM report_templates
    WHERE organization_id = p_organization_id
      AND report_type = 'CAMPAIGN'
      AND is_default = true
    LIMIT 1;
  END IF;

  -- Create report record
  INSERT INTO generated_reports (
    organization_id,
    campaign_id,
    report_type,
    template_id,
    title,
    status,
    period_start,
    period_end,
    requested_by,
    generation_started_at
  ) VALUES (
    p_organization_id,
    p_campaign_id,
    COALESCE(v_template.report_type, 'CAMPAIGN'),
    v_template.id,
    'Campaign Report: ' || v_campaign.name,
    'PENDING',
    COALESCE(p_period_start, v_campaign.created_at),
    COALESCE(p_period_end, NOW()),
    p_user_id,
    NOW()
  )
  RETURNING id INTO v_report_id;

  RETURN v_report_id;
END;
$$;

/**
 * Get latest campaign report
 */
CREATE OR REPLACE FUNCTION get_latest_campaign_report(
  p_campaign_id UUID,
  p_organization_id UUID
)
RETURNS TABLE (
  report_id UUID,
  report_type report_type,
  status report_status,
  title TEXT,
  created_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT
    gr.id,
    gr.report_type,
    gr.status,
    gr.title,
    gr.created_at,
    gr.generation_completed_at
  FROM generated_reports gr
  WHERE gr.campaign_id = p_campaign_id
    AND gr.organization_id = p_organization_id
    AND gr.status = 'COMPLETE'
  ORDER BY gr.created_at DESC
  LIMIT 1;
END;
$$;

/**
 * Summarize campaign metrics (data aggregation for GPT)
 * Returns structured metrics snapshot
 */
CREATE OR REPLACE FUNCTION summarize_campaign_metrics(
  p_campaign_id UUID,
  p_organization_id UUID,
  p_period_start TIMESTAMPTZ DEFAULT NULL,
  p_period_end TIMESTAMPTZ DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_metrics JSONB;
  v_start TIMESTAMPTZ;
  v_end TIMESTAMPTZ;
  v_total_contacts INTEGER;
  v_total_pitches INTEGER;
  v_total_placements INTEGER;
  v_avg_lead_score NUMERIC;
  v_qualified_leads INTEGER;
  v_avg_sentiment NUMERIC;
  v_total_agent_runs INTEGER;
  v_successful_tasks INTEGER;
  v_total_tasks INTEGER;
BEGIN
  -- Set timeframe
  v_start := COALESCE(p_period_start, (SELECT created_at FROM campaigns WHERE id = p_campaign_id));
  v_end := COALESCE(p_period_end, NOW());

  -- Contact count
  SELECT COUNT(*)
  INTO v_total_contacts
  FROM contacts
  WHERE organization_id = p_organization_id
    AND EXISTS (
      SELECT 1 FROM contact_campaigns
      WHERE contact_id = contacts.id AND campaign_id = p_campaign_id
    );

  -- Pitch count (from pitch_workflows or outreach)
  SELECT COUNT(*)
  INTO v_total_pitches
  FROM pitch_workflows
  WHERE campaign_id = p_campaign_id
    AND organization_id = p_organization_id
    AND created_at BETWEEN v_start AND v_end;

  -- Placement count (assuming success status)
  SELECT COUNT(*)
  INTO v_total_placements
  FROM pitch_workflows
  WHERE campaign_id = p_campaign_id
    AND organization_id = p_organization_id
    AND status = 'SUCCESS'
    AND created_at BETWEEN v_start AND v_end;

  -- Lead scoring metrics
  SELECT AVG(raw_score), COUNT(*) FILTER (WHERE stage = 'QUALIFIED')
  INTO v_avg_lead_score, v_qualified_leads
  FROM lead_scores
  WHERE organization_id = p_organization_id
    AND campaign_id = p_campaign_id;

  -- Sentiment metrics
  SELECT AVG(avg_sentiment_score)
  INTO v_avg_sentiment
  FROM contact_channel_profiles
  WHERE organization_id = p_organization_id
    AND contact_id IN (
      SELECT contact_id FROM contact_campaigns WHERE campaign_id = p_campaign_id
    );

  -- Agent performance
  SELECT COUNT(*)
  INTO v_total_agent_runs
  FROM agent_memory
  WHERE organization_id = p_organization_id
    AND campaign_id = p_campaign_id
    AND created_at BETWEEN v_start AND v_end;

  -- Task performance
  SELECT
    COUNT(*) FILTER (WHERE status = 'COMPLETED'),
    COUNT(*)
  INTO v_successful_tasks, v_total_tasks
  FROM tasks
  WHERE organization_id = p_organization_id
    AND campaign_id = p_campaign_id
    AND created_at BETWEEN v_start AND v_end;

  -- Build metrics JSON
  v_metrics := jsonb_build_object(
    'period', jsonb_build_object(
      'start', v_start,
      'end', v_end
    ),
    'contacts', jsonb_build_object(
      'total', COALESCE(v_total_contacts, 0),
      'qualified', COALESCE(v_qualified_leads, 0)
    ),
    'outreach', jsonb_build_object(
      'pitches', COALESCE(v_total_pitches, 0),
      'placements', COALESCE(v_total_placements, 0),
      'conversionRate', CASE
        WHEN v_total_pitches > 0 THEN ROUND((v_total_placements::NUMERIC / v_total_pitches) * 100, 2)
        ELSE 0
      END
    ),
    'leadScoring', jsonb_build_object(
      'avgScore', COALESCE(ROUND(v_avg_lead_score, 1), 0),
      'qualifiedCount', COALESCE(v_qualified_leads, 0)
    ),
    'sentiment', jsonb_build_object(
      'avgScore', COALESCE(ROUND(v_avg_sentiment * 100, 1), 0)
    ),
    'agents', jsonb_build_object(
      'totalRuns', COALESCE(v_total_agent_runs, 0)
    ),
    'tasks', jsonb_build_object(
      'total', COALESCE(v_total_tasks, 0),
      'completed', COALESCE(v_successful_tasks, 0),
      'completionRate', CASE
        WHEN v_total_tasks > 0 THEN ROUND((v_successful_tasks::NUMERIC / v_total_tasks) * 100, 2)
        ELSE 0
      END
    )
  );

  RETURN v_metrics;
END;
$$;

/**
 * Mark report as complete
 */
CREATE OR REPLACE FUNCTION complete_report_generation(
  p_report_id UUID,
  p_executive_summary TEXT,
  p_key_findings TEXT[],
  p_recommendations TEXT[],
  p_performance_analysis TEXT,
  p_agent_effectiveness TEXT,
  p_sentiment_analysis TEXT,
  p_sections JSONB,
  p_charts JSONB,
  p_metrics_snapshot JSONB
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_started_at TIMESTAMPTZ;
BEGIN
  -- Get start time
  SELECT generation_started_at INTO v_started_at
  FROM generated_reports
  WHERE id = p_report_id;

  -- Update report
  UPDATE generated_reports
  SET
    status = 'COMPLETE',
    executive_summary = p_executive_summary,
    key_findings = p_key_findings,
    strategic_recommendations = p_recommendations,
    performance_analysis = p_performance_analysis,
    agent_effectiveness_summary = p_agent_effectiveness,
    sentiment_analysis = p_sentiment_analysis,
    sections = p_sections,
    charts = p_charts,
    metrics_snapshot = p_metrics_snapshot,
    generation_completed_at = NOW(),
    generation_duration_ms = EXTRACT(EPOCH FROM (NOW() - v_started_at)) * 1000,
    updated_at = NOW()
  WHERE id = p_report_id;

  -- Update campaign latest_report_id
  UPDATE campaigns
  SET latest_report_id = p_report_id
  WHERE id = (SELECT campaign_id FROM generated_reports WHERE id = p_report_id);

  RETURN TRUE;
END;
$$;

/**
 * Mark report as failed
 */
CREATE OR REPLACE FUNCTION fail_report_generation(
  p_report_id UUID,
  p_error_message TEXT
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE generated_reports
  SET
    status = 'FAILED',
    error_message = p_error_message,
    updated_at = NOW()
  WHERE id = p_report_id;

  RETURN TRUE;
END;
$$;

-- =====================================================
-- UPDATE TIMESTAMP TRIGGERS
-- =====================================================

CREATE TRIGGER update_report_templates_updated_at
  BEFORE UPDATE ON report_templates
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_generated_reports_updated_at
  BEFORE UPDATE ON generated_reports
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- SEED DEFAULT TEMPLATES
-- =====================================================

-- Note: This will be run per organization during onboarding
-- For now, just structure the INSERT
-- INSERT INTO report_templates (organization_id, name, description, report_type, is_default, sections)
-- VALUES (...);

-- =====================================================
-- COMMENTS
-- =====================================================

COMMENT ON TABLE report_templates IS 'Reusable report configuration templates';
COMMENT ON TABLE generated_reports IS 'Generated reports with GPT insights and metrics';
COMMENT ON FUNCTION generate_campaign_report IS 'Creates a new report generation request';
COMMENT ON FUNCTION summarize_campaign_metrics IS 'Aggregates campaign metrics for GPT analysis';
COMMENT ON FUNCTION complete_report_generation IS 'Marks report as complete with all content';
